//
//  TorManager.swift
//  AdParticipesCumCepis
//
//  Created by Benjamin Erhart on 06.10.21.
//  Copyright Â© 2021 Guardian Project. All rights reserved.
//

import Foundation
import Tor

class TorManager {

    private enum Errors: Error {
        case cookieUnreadable
        case noSocksAddr
    }

    static let shared = TorManager()

    static let localhost = "127.0.0.1"

    static let webServerPort: UInt = 8080

    public lazy var serviceDir: URL? = {
        guard let args = torConf.arguments,
              let i = args.firstIndex(of: "--HiddenServiceDir"),
              i + 1 < args.count && !args[i + 1].isEmpty
        else {
            return nil
        }

        return URL(fileURLWithPath: args[i + 1])
    }()

    public lazy var onionAuth: TorOnionAuth? = {
        guard let url = serviceDir else {
            return nil
        }

        let pubKeyDir = url.appendingPathComponent("authorized_clients", isDirectory: true)

        // Try to create the public key directory, if it doesn't exist, yet.
        // Tor will do that on first start, but then we would need to restart
        // to make it load the key.
        // However, we need to be careful with access flags, because
        // otherwise Tor will complain and reject its use.
        try? FileManager.default.createSecureDirIfNotExists(at: pubKeyDir)

        return TorOnionAuth(withPrivateDir: nil, andPublicDir: pubKeyDir)
    }()

    public lazy var serviceUrl: URL? = {
        guard let url = serviceDir?.appendingPathComponent("hostname"),
              let hostname = try? String(contentsOf: url).trimmingCharacters(in: .whitespacesAndNewlines)
        else {
            return nil
        }

        var urlc = URLComponents()
        urlc.host = hostname
        urlc.scheme = "http"

        return urlc.url
    }()


    private var torThread: TorThread?

    private lazy var torConf: TorConfiguration = {
        let conf = TorConfiguration()
        conf.ignoreMissingTorrc = true
        conf.cookieAuthentication = true
        conf.autoControlPort = true

        conf.options = ["Log": "notice stdout",
                        "LogMessageDomains": "1",
                        "SafeLogging": "0",
                        "SocksPort": "auto",
                        "HiddenServicePort": "80 \(TorManager.localhost):\(TorManager.webServerPort)",
                        "AvoidDiskWrites": "1"]

        // Store data in <appdir>/Library/Caches/tor (Library/Caches/ is for things that can persist between
        // launches -- which we'd like so we keep descriptors & etc -- but don't need to be backed up because
        // they can be regenerated by the app)
        if let dataDir = FileManager.default.cacheDir?.appendingPathComponent("tor", isDirectory: true) {

            log("dataDir=\(dataDir)")

            // Create tor data directory if it does not yet exist.
            try? FileManager.default.createDirectory(at: dataDir, withIntermediateDirectories: true)

            conf.dataDirectory = dataDir

            // Tor will create that directory by itself.
            let webDir = dataDir.appendingPathComponent("web", isDirectory: true)

            // Need to use #arguments instead of #options because order is important.
            conf.arguments += ["--HiddenServiceDir", webDir.path]
        }

        return conf
    }()

    private var torController: TorController?

    private var torRunning: Bool {
        guard torThread?.isExecuting ?? false else {
            return false
        }

        if let lock = torConf.dataDirectory?.appendingPathComponent("lock") {
            return FileManager.default.fileExists(atPath: lock.path)
        }

        return false
    }

    private lazy var controllerQueue = DispatchQueue.global(qos: .userInitiated)


    private init() {
    }

    func start(_ progressCallback: @escaping (Int) -> Void,
               _ completion: @escaping (Error?, _ socksAddr: String?) -> Void)
    {
        if !torRunning {
            torThread = TorThread(configuration: self.torConf)
            torThread?.start()
        }

        controllerQueue.asyncAfter(deadline: .now() + 0.65) {
            if self.torController == nil, let cpf = self.torConf.controlPortFile {
                self.torController = TorController(controlPortFile: cpf)
            }

            if !(self.torController?.isConnected ?? false) {
                do {
                    try self.torController?.connect()
                }
                catch let error {
                    return completion(error, nil)
                }
            }

            guard let cookie = self.torConf.cookie else {
                return completion(Errors.cookieUnreadable, nil)
            }

            self.torController?.authenticate(with: cookie) { success, error in
                if let error = error {
                    return completion(error, nil)
                }

                var progressObs: Any?
                progressObs = self.torController?.addObserver(forStatusEvents: {
                    (type, severity, action, arguments) -> Bool in

                    if type == "STATUS_CLIENT" && action == "BOOTSTRAP" {
                        let progress = Int(arguments!["PROGRESS"]!)!

                        progressCallback(progress)

                        if progress >= 100 {
                            self.torController?.removeObserver(progressObs)
                        }

                        return true
                    }

                    return false
                })

                var observer: Any?
                observer = self.torController?.addObserver(forCircuitEstablished: { established in
                    guard established else {
                        return
                    }

                    self.torController?.removeObserver(observer)

                    self.torController?.getInfoForKeys(["net/listeners/socks"]) { response in
                        guard let socksAddr = response.first, !socksAddr.isEmpty else {
                            return completion(Errors.noSocksAddr, nil)
                        }

                        completion(nil, socksAddr)
                    }
                })
            }
        }
    }

    func stop() {
        torController?.disconnect()
        torController = nil

        torThread?.cancel()
        torThread = nil
    }

    func getCircuits(_ completion: @escaping ([TorCircuit]) -> Void) {
        torController?.getCircuits(completion)
    }

    func close(_ circuits: [TorCircuit], _ completion: ((Bool) -> Void)?) {
        torController?.close(circuits, completion: completion)
    }

    private func log(_ message: String) {
        print("[\(String(describing: type(of: self)))] \(message)")
    }
}
